# Learn Next.js

## 괄호() 사용하면 괄호 안에 이름이 url 경로에 포함 안됨

> 실행방법
> 
> 경로는 package.json 파일이 있는 폴더에서 실행
> 
> npm run dev

## Tailwind
새 프젝 시작 시 Next.js Tailwind 사용할 건지 물어봄 그때 yes 하면 자동으로 필요한 패키지 설치 및 애플리케이션에 Tailwind 구성

## css 모듈
각 구성요소에 대해 고유한 클래스 이름을 생성하므로 스타일 충돌에 대해 걱정할 필요 없다

## clsx
클래스 이름을 쉽게 전환할 수 있는 라이브러리

## 글꼴
Next.js는 빌드 시 글꼴 파일을 다운로드하고 이를 다른 정적 자산과 함께 호스팅한다. 

사용자가 애플리케이션을 방문할 때 성능에 영향을 미칠 수 있는 글꼴에 대한 추가 네트워크 요청이 없음을 의미

## 루트 레이아웃
루트 레이아웃에 추가하는 모든 UI는 애플리케이션의 모든 페이지에서 공유 됨

루트 레이아웃을 사용하여 ``` <html> ``` 및 ``` <boby> ``` 태그를 수정하고 메타데이터를 추가 가능

고유한 레이아웃은 루트 레이아웃에 UI 추가할 이유 없음

## Next.js에서 레이아웃 파일
레이아웃파일의 목적은 애플리케이션의 모든 페이지에서 사용할 수 있는 공유 레이아웃을 만드는 가장 좋은 방법

## ``` <Link> ```
브라우저의 뷰포트에 나타날 때마다 Next.js는 백그라운드에서 연결된 경로에 대한 코드를 자동으로 미리 가져옴

사용자가 링크를 클릭하면 대상 페이지의 코드가 이미 백그라운드에 로드되어 페이지 전환이 거의 즉각적으로 이루어짐

## usePathname
현재 URL의 경로 이름을 읽을 수 있는 클라이언트 구성 요소 후크 및 현재의 URL의 경로 이름 문자열을 반환
```
'use client'
 
import { usePathname } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const pathname = usePathname()
  return <p>Current pathname: {pathname}</p>
}
```

## 데이터베이스
클라이언트에서 데이터를 가져올 때 데이터베이스에 직접 쿼리하면 데이터베이스 비밀 노출됨

서버 구성요소 사용하여 데이터베이스 가져오기

Promise 지원하여 데이터 가져오기와 같은 비동기 작업을 위한 더 간단한 솔루션 제공

useEffect, useState 또는 데이터 가져오기 라이브러리에 손을 대지 않고 비동기/대기(async/await) 구문을 사용

서버 구성요소는 서버에서 실행되므로 값비싼 데이터 가져오기 및 로직을 서버에 유지하고 결과만 클라이언트로 보낼 수 있다.

서버 구성요소는 서버에서 실행되므로 추가 API 계층 없이 데이터베이스를 직접 조회 가능

서버 구성요소 사용하면 데이터베이스에서 직접 데이터를 가져올 수 있다.

### async/await
콜백, Promise 체인의 단점은 async와 await로 보완

함수를 정의할 때 async를 함수 앞에 붙이면, “이 함수는 비동기적인 함수이고 Promise를 반환한다”라고 선언

반환 값이 Promise 생성 함수가 아니어도 반환되는 값을 Promise 객체에 넣는다.

await는 async 함수 안에만 사용할 수 있는 특별한 문법,

Promise를 반환하는 함수 앞에 await를 붙이면, 해당 Promise의 상태가 바뀔 때까지 코드가 기다림.

Promise가 성공 상태 또는 실패 상태로 바뀌기 전까지는 다음 연산을 시작하지 않는다

## 요청 폭포수?
폭포수는 이전 요청의 완료에 따라 달라지는 일련의 네트워크 요청을 나타낸다.

데이터 가져오기의 경우 각 요청은 이전 요청이 데이터를 반환한 후에만 시작 가능

다음 요청을 하기 전에 조건을 충족하려 하면 폭포수 패턴 사용

EX) 사용자 ID 와 프로필 정보를 먼저 가져오고 싶을 수 있다. ID가 있으면 친구 목록을 가져올 수 있다.

## 병렬테이터 가져오기
폭포수 방지하는 일반적인 방법

JavaScript에서 Promise.all() 또는 Promise.allSettled() 함수를 사용하여 모든 약속을 동시에 시작 가능

## 스트리밍
경로를 더 작은 "chunks" 로 분해하고 준비가 되면 서버에서 클라이언트로 점진적으로 스트리밍할 수 있는 데이터 전송 기술

스트리밍하면 느린 데이터 요청이 전체 페이지를 차단하는 것을 방지할 수 있다. 

이를 통해 사용자는 UI가 사용자에게 표시되기 전에 모든 데이터가 로드될 때까지 기다리지 않고 페이지의 일부를 보고 상호작용 가능

Next.js 스트리밍 구현 방법
1. 페이지 수준에서 loading.tsx 파일 사용
2. 특정 구성 요소의 경우 ``` <Suspense>```

### 전체 페이지 스트리밍
1. loading.tsxSuspense를 기반으로 구축된 특별한 Next.js 파일로, 페이지 콘텐츠가 로드되는 동안 대체 UI로 표시할 폴백 UI를 생성
2. 정적 이므로 ``` <SideNav>``` 즉시 표시됩니다. 사용자는 ``` <SideNav> ```동적 콘텐츠가 로드되는 동안 상호 작용 가능
3. 사용자는 다른 페이지로 이동하기 전에 페이지 로드가 완료될 때까지 기다릴 필요가 없다(이를 중단 가능한 탐색이라고 함).

로딩 뼈대 추가
-> loading.tsx 포함하는 모든 UI는 정적 파일의 일부로 포함되어 먼저 전송 그런 다음 나머지 동적 콘텐츠가 서버에서 클라이언트로 스트리밍
```
import DashboardSkeleton from '@/app/ui/skeletons';
 
export default function Loading() {
  return <DashboardSkeleton />;
}
```

### 구성요소 스트리밍
Suspense를 사용하면 일부 조건이 충족될 때까지(예: 데이터 로드) 애플리케이션의 렌더링 부분을 연기 가능

Suspense에서 동적 구성요소를 래핑할 수 있습니다. 그런 다음 동적 구성요소가 로드되는 동안 표시할 대체 구성요소를 전달

### Suspense 경계를 배치할 위치 결정
1. 페이지가 스트리밍될 때 사용자가 페이지를 경험하기를 원하는 방식입니다.
2. 어떤 콘텐츠에 우선순위를 두고 싶은지.
3. 구성요소가 데이터 가져오기에 의존하는 경우.

서스펜스 경계를 ​​배치하는 위치는 애플리케이션에 따라 달라집니다. 일반적으로 데이터 가져오기를 필요한 구성 요소로 이동한 다음 Suspense에서 해당 구성 요소를 래핑하는 것이 좋습니다. 

그러나 애플리케이션에 필요한 경우 섹션이나 전체 페이지를 스트리밍하는 데 아무런 문제가 없습니다.

- 가져오는 데이터를 필요한 구성 요소로 이동하면 보다 세부적인 Suspense 경계를 만들 수 있습니다. 이를 통해 특정 구성 요소를 스트리밍하고 UI가 차단되는 것을 방지

## 부분 사전 렌더링
- 구성 ``` <SideNav> ``` 요소는 데이터에 의존하지 않으며 사용자에게 개인화되지 않으므로 정적
- 구성 요소는 ``` <Page> ``` 자주 변경되는 데이터에 의존하고 사용자에게 개인화되므로 동적
