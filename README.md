# Learn Next.js

## Next.js?
> 풀스택 웹 어플리케이션을 구축하기 위한 React 프레임워크
>
> 프론트 단의 UI구성은 React로 하고, Next.js를 사용하여 추가 기능과 최적화 수행
>
> Next.js는 동적이며 빠른 React 어플리케이션을 구축하는 데 도움

## 괄호() 사용하면 괄호 안에 이름이 url 경로에 포함 안됨

> 실행방법
> 
> 경로는 package.json 파일이 있는 폴더에서 실행
> 
> npm run dev
>
> 이메일: user@nextmail.com
> 비밀번호: 123456


## Tailwind
새 프젝 시작 시 Next.js Tailwind 사용할 건지 물어봄 그때 yes 하면 자동으로 필요한 패키지 설치 및 애플리케이션에 Tailwind 구성

## css 모듈
각 구성요소에 대해 고유한 클래스 이름을 생성하므로 스타일 충돌에 대해 걱정할 필요 없다

## clsx
클래스 이름을 쉽게 전환할 수 있는 라이브러리

## 글꼴
Next.js는 빌드 시 글꼴 파일을 다운로드하고 이를 다른 정적 자산과 함께 호스팅한다. 

사용자가 애플리케이션을 방문할 때 성능에 영향을 미칠 수 있는 글꼴에 대한 추가 네트워크 요청이 없음을 의미

## 루트 레이아웃
루트 레이아웃에 추가하는 모든 UI는 애플리케이션의 모든 페이지에서 공유 됨

루트 레이아웃을 사용하여 ``` <html> ``` 및 ``` <boby> ``` 태그를 수정하고 메타데이터를 추가 가능

고유한 레이아웃은 루트 레이아웃에 UI 추가할 이유 없음

## Next.js에서 레이아웃 파일
레이아웃파일의 목적은 애플리케이션의 모든 페이지에서 사용할 수 있는 공유 레이아웃을 만드는 가장 좋은 방법

## ``` <Link> ```
브라우저의 뷰포트에 나타날 때마다 Next.js는 백그라운드에서 연결된 경로에 대한 코드를 자동으로 미리 가져옴

사용자가 링크를 클릭하면 대상 페이지의 코드가 이미 백그라운드에 로드되어 페이지 전환이 거의 즉각적으로 이루어짐

## usePathname
현재 URL의 경로 이름을 읽을 수 있는 클라이언트 구성 요소 후크 및 현재의 URL의 경로 이름 문자열을 반환
```
'use client'
 
import { usePathname } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const pathname = usePathname()
  return <p>Current pathname: {pathname}</p>
}
```

## 데이터베이스
클라이언트에서 데이터를 가져올 때 데이터베이스에 직접 쿼리하면 데이터베이스 비밀 노출됨

서버 구성요소 사용하여 데이터베이스 가져오기

Promise 지원하여 데이터 가져오기와 같은 비동기 작업을 위한 더 간단한 솔루션 제공

useEffect, useState 또는 데이터 가져오기 라이브러리에 손을 대지 않고 비동기/대기(async/await) 구문을 사용

서버 구성요소는 서버에서 실행되므로 값비싼 데이터 가져오기 및 로직을 서버에 유지하고 결과만 클라이언트로 보낼 수 있다.

서버 구성요소는 서버에서 실행되므로 추가 API 계층 없이 데이터베이스를 직접 조회 가능

서버 구성요소 사용하면 데이터베이스에서 직접 데이터를 가져올 수 있다.

### async/await
콜백, Promise 체인의 단점은 async와 await로 보완

함수를 정의할 때 async를 함수 앞에 붙이면, “이 함수는 비동기적인 함수이고 Promise를 반환한다”라고 선언

반환 값이 Promise 생성 함수가 아니어도 반환되는 값을 Promise 객체에 넣는다.

await는 async 함수 안에만 사용할 수 있는 특별한 문법,

Promise를 반환하는 함수 앞에 await를 붙이면, 해당 Promise의 상태가 바뀔 때까지 코드가 기다림.

Promise가 성공 상태 또는 실패 상태로 바뀌기 전까지는 다음 연산을 시작하지 않는다

## 요청 폭포수?
폭포수는 이전 요청의 완료에 따라 달라지는 일련의 네트워크 요청을 나타낸다.

데이터 가져오기의 경우 각 요청은 이전 요청이 데이터를 반환한 후에만 시작 가능

다음 요청을 하기 전에 조건을 충족하려 하면 폭포수 패턴 사용

EX) 사용자 ID 와 프로필 정보를 먼저 가져오고 싶을 수 있다. ID가 있으면 친구 목록을 가져올 수 있다.

## 병렬테이터 가져오기
폭포수 방지하는 일반적인 방법

JavaScript에서 Promise.all() 또는 Promise.allSettled() 함수를 사용하여 모든 약속을 동시에 시작 가능

## 스트리밍
경로를 더 작은 "chunks" 로 분해하고 준비가 되면 서버에서 클라이언트로 점진적으로 스트리밍할 수 있는 데이터 전송 기술

스트리밍하면 느린 데이터 요청이 전체 페이지를 차단하는 것을 방지할 수 있다. 

이를 통해 사용자는 UI가 사용자에게 표시되기 전에 모든 데이터가 로드될 때까지 기다리지 않고 페이지의 일부를 보고 상호작용 가능

Next.js 스트리밍 구현 방법
1. 페이지 수준에서 loading.tsx 파일 사용
2. 특정 구성 요소의 경우 ``` <Suspense>```

### 전체 페이지 스트리밍
1. loading.tsxSuspense를 기반으로 구축된 특별한 Next.js 파일로, 페이지 콘텐츠가 로드되는 동안 대체 UI로 표시할 폴백 UI를 생성
2. 정적 이므로 ``` <SideNav>``` 즉시 표시됩니다. 사용자는 ``` <SideNav> ```동적 콘텐츠가 로드되는 동안 상호 작용 가능
3. 사용자는 다른 페이지로 이동하기 전에 페이지 로드가 완료될 때까지 기다릴 필요가 없다(이를 중단 가능한 탐색이라고 함).

로딩 뼈대 추가
-> loading.tsx 포함하는 모든 UI는 정적 파일의 일부로 포함되어 먼저 전송 그런 다음 나머지 동적 콘텐츠가 서버에서 클라이언트로 스트리밍
```
import DashboardSkeleton from '@/app/ui/skeletons';
 
export default function Loading() {
  return <DashboardSkeleton />;
}
```

### 구성요소 스트리밍
Suspense를 사용하면 일부 조건이 충족될 때까지(예: 데이터 로드) 애플리케이션의 렌더링 부분을 연기 가능

Suspense에서 동적 구성요소를 래핑할 수 있습니다. 그런 다음 동적 구성요소가 로드되는 동안 표시할 대체 구성요소를 전달

### Suspense 경계를 배치할 위치 결정
1. 페이지가 스트리밍될 때 사용자가 페이지를 경험하기를 원하는 방식입니다.
2. 어떤 콘텐츠에 우선순위를 두고 싶은지.
3. 구성요소가 데이터 가져오기에 의존하는 경우.

서스펜스 경계를 ​​배치하는 위치는 애플리케이션에 따라 달라집니다. 일반적으로 데이터 가져오기를 필요한 구성 요소로 이동한 다음 Suspense에서 해당 구성 요소를 래핑하는 것이 좋습니다. 

그러나 애플리케이션에 필요한 경우 섹션이나 전체 페이지를 스트리밍하는 데 아무런 문제가 없습니다.

- 가져오는 데이터를 필요한 구성 요소로 이동하면 보다 세부적인 Suspense 경계를 만들 수 있습니다. 이를 통해 특정 구성 요소를 스트리밍하고 UI가 차단되는 것을 방지

## 부분 사전 렌더링
- 구성 ``` <SideNav> ``` 요소는 데이터에 의존하지 않으며 사용자에게 개인화되지 않으므로 정적
- 구성 요소는 ``` <Page> ``` 자주 변경되는 데이터에 의존하고 사용자에게 개인화되므로 동적
  
- 요약
  1. 서버와 데이터베이스 간의 대기 시간을 줄이기 위해 애플리케이션 코드와 동일한 지역에 데이터베이스 생성
  2. React Server Components 사용하여 서버에 데이터 가져옴 (서버에서 비용 많이 드는 데이터 가져오기 및 논리 유지, 클라이언트 측 JavaScript 번들 줄이고, 데이터베이스 비밀이 클라이언트에 노출되는 것 방지)
  3. SQL 사용하여 필요한 데이터만 가져오므로 각 요청에 대해 전송되는 데이터의 양과 메모리 내 데이터를 변환하는 데 필요한 JavaScript 양이 줄어듬
  4. JavaScript로 데이터 가져오기를 병렬화하는 것이 합리적
  5. 느린 데이터 요청이 전체 페이지를 차단하는 것을 방지하고 사용자가 모든 것이 로드될 때까지 기다리지 않고 UI와 상호 작용을 시작할 수 있도록 스트리밍을 구현
  6. 데이터 가져오기를 필요한 구성 요소로 이동하여 부분 사전 렌더링을 준비할 때 경로의 어느 부분이 동적으로 이루어져야 하는지 분리

 ## 검색 및 페이지네이션
 1. ``` <Search/> ``` 검색
    - 클라이언트와 서버에 걸쳐 있다. 사용자가 클라이언트에서 검색하면 URL 매개변수가 업데이트되고, 서버에서 데이터를 가져오며 테이블은 새 데이터로 서버에서 다시 렌더링
    - URL 검색 매개변수 사용 이유?
      - 북마크 및 공유 가능
      - 서버 측 렌터링 및 초기 로드
      - 분석 및 추적
    - ***클라이언트 구성요소이므로 SearchParams() 후크를 사용하여 클라이언트에서 매개변수에 엑세스***
    - ``` useSearchParams ```
      - 현재 URL의 매개변수에 엑세스할 수 있다.
   
        예를 들어, 이 URL에 대한 검색 매개변수는 ``` /dashboard/invoices?page=1&query=pending ``` 다음과 같습니다 ``` {page: '1', query: 'pending'} ```
      - URL 쿼리 매개변수를 조작하기 위한 유틸리티 메서드를 제공하는 웹 API
    - ``` usePathname ```
      - 현재 URL의 경로명 읽기 가능
     
        예를 들어 경로의 경우는 ``` /dashboard/invoices을 usePathname ``` 반환 ``` '/dashboard/invoices' ```
    - ``` useRouter ```
      - 프로그래밍 방식으로 클라이언트 구성 요소 내의 경로 간 탐색을 활성화
    ``` - 구현단계
      1. 사용자의 입력 캡쳐
      2. 검색 매개변수로 URL 업뎃
      3. URL 입력 필드와 동기화 상태로 유지
      4. 검색어를 반영하도록 테이블 업뎃 ```
    - ``` "use client" ``` - 클라이언트 구성 요소, 이벤트 리스너와 후크를 사용할 수 있습니다.
    - URL 입력의 동기화 유지
      - defaultValue VS value  Controlled VS Uncontrolled
      - 상태를 사용하여 입력의 값을 관리하는 경우 값 속성을 사용하여 제어되는 구성 요소로 만듦
        - 즉, React 가 입력의 상태 관리
      - 그러나 상태를 사용하지 않으므로 defaultValue 사용 가능
      - 네이티브 입력이 자체 상태를 관리한다는 것 의미
      - 검색 쿼리를 상태 대신 URL에 저장하기 때문에 괜찮
    - ``` 키를 누를때마다 사용자가 입력하는 걸 캡쳐해서 URL 업뎃을 하므로 데이터베이스를 쿼리하게 된다. ```
    - ***URLsearchParams***
      -  URL 쿼리 매개 변수를 조작하는 유틸리티 방법을 제공하는 웹 API
    - ***디바운싱***
      - 함수가 실행될 수 있는 속도를 제한하는 프로그래밍 방식
      - 작동방식 :
        1. Trigger Event : 디바운싱되어야 하는 이벤트(검색창의 키 입력 등) 발생하면 타이머 시작
        2. 대기 : 타이머가 만료되기 전에 새로운 이벤트가 발생하면 타이머 재설정
        3. 실행 : 타이머가 카운트다운 끝에 도달하면 디바운싱된 함수 실행 
 2. ``` <Pagination/> ``` 페이지네이션
 3. ``` <Table/> ``` 테이블
    - *** ```<Table>``` 자체 데이터를 가져오는 Server Component이므로 SearchParams 소품을 페이지에서 구성 요소로 전달 가능
    - 일반적으로 틀라이언트에서 매개변수를 읽으려면 검색 매개변수() 후크를 사용하여 서버로 돌아갈 필요없다.

 ## 데이터 변형
- ```'use server'```를 추가하면 파일 내에서 내보낸 모든 기능을 서버 기능으로 표시

  서버 기능을 클라이언트 및 서버 구성 요소로 가져올 수 있으므로 매우 다양하게 사용 가능

- 동적 경로 세그먼트
  - Next.js 를 사용하면 정확한 세그먼트 이름을 모르고 데이터를 기반으로 경로를 생성하려는 경우 동적 경로 세그먼트 생성 가능
  - ex) 블로그 게시물 제목, 제품 페이지 등
  - 폴더 이름을 대괄호로 묶어 동적 경로 세그먼트를 만들 수 있습니다
  - ex) ```[id]```, ```[post]``` 또는 ```[slug]```.
- UUID와 자동 증가(Auto-incrementing) 키
  - 키를 증가시키는 대신(예: 1, 2, 3 등) UUID를 사용합니다.
  - 이렇게 하면 URL이 길어집니다.
  - 그러나 UUID는 ID 충돌 위험을 제거하고 전역적으로 고유하며 열거 공격 위험을 줄여 대규모 데이터베이스에 이상적입니다.
  - 더 깔끔한 URL을 선호한다면 자동 증가 키를 사용하는 것이 좋습니다.

 ## 접근성
 - 양식 접근성 개선
  1. Semantic HTML
     - ``` <div> ``` 대신 시맨틱 요소(```<input>```, ```<option>``` 등)를 사용
     - 이를 통해 보조 기술(AT)은 입력 요소에 집중하고 사용자에게 적절한 상황 정보를 제공하여 양식을 더 쉽게 탐색하고 이해 가능
  2. Labelling
     - ```<label>```과 htmlFor 속성을 포함하면 각 양식 필드에 설명 텍스트 라벨이 포함
     - 컨텍스트를 제공하여 AT 지원을 향상시키고 사용자가 레이블을 클릭하여 해당 입력 필드에 집중할 수 있게 함으로써 유용성 향상
  3. Focus Outline
     - 초점이 맞춰졌을 때 윤곽선을 표시하도록 필드의 스타일이 적절하게 지정
     - 페이지의 활성 요소를 시각적으로 표시하여 키보드와 화면 판독기 사용자 모두가 양식의 위치를 이해하는 데 도움이 되므로 접근성에 매우 중요
     - ```tab```을 눌러 이를 확인 가능
 - 서버측 검증
  - 데이터를 데이터베이스로 보내기 전에 데이터가 예상된 형식인지 확인
  - 악의적인 사용자가 클라이언트 측 유효성 검사를 우회하는 위험 감소
  - 유효한 데이터로 간주되는 정보에 대한 하나의 진실 소스를 확보

 ## NextAuth.js
  - 애플리케이션에 인증을 추가하려면 NextAuth.js는 세션 관리, 로그인 및 로그아웃, 기타 인증 측면과 관련된 많은 복잡성을 추상화 함
  - 이러한 기능을 수동으로 구현할 수도 있지만 이 프로세스는 시간이 많이 걸리고 오류가 발생하기 쉽다
  - NextAuth.js는 Next.js 애플리케이션의 인증을 위한 통합 솔루션을 제공하여 프로세스 단순화

 ## 메타데이터
  - 메타데이터란?
    - 웹 개발에서 메타데이터는 웹페이지에 대한 추가 세부정보를 제공
    - 페이지를 방문하는 사용자에게는 메타데이터가 표시되지 않는다.
    - 대신 페이지의 HTML, 일반적으로 ``` <head> ``` 요소 내에 삽입되어 뒤에서 작동
    - 숨겨진 정보는 웹페이지의 콘텐츠를 더 잘 이해해야하는 검색 엔진 및 기타 시스템에 매우 중요

  - 메타데이터 중요성
    - 웹 페이지의 SEO를 향상시키는데 중요한 역할을 하여 검색 엔진과 소셜 미디어 플랫폼에서 웹페이지에 대한 접근성과 이해도를 높인다.
      - SEO  Search Engine Optimization  검색 엔진 최적화
    - 적절한 메타테이터는 검색 엔진이 웹 페이지를 효과적으로 색인화하여 검색 결과에서 순위를 높이는 데 도움 된다.
    - Open Graph와 같은 메타데이터는 소셜 미디어에서 공유 링크의 모양을 개선하여 사용자에게 콘텐츠를 더욱 매력적이고 유익하게 만든다.
   
  - 메타데이터 유형
    - Title Metadata
      - 브라우저 탭에 표시되는 웹페이지의 제목 담당
      - 검색 엔진이 웹페이지의 내용을 이해하는 데 도움이 되므로 SEO에 매우 중요
      - ```<title>Page Title</title>```
    - 설명 Metadata
      - 웹페이지 콘텐츠에 대한 간략한 개요를 제공하며 검색 엔진 결과에 자주 표시
      - ``` <meta name="description" content="A brief description of the page content." /> ```
    - 키워드 Metadata
      - 웹페이지 콘텐츠와 관련된 키워드가 포함되어 있어 검색 엔진이 페이지를 색인화하는 데 도움 됨
      - ``` <meta name="keywords" content="keyword1, keyword2, keyword3" /> ```
    - 오픈 그래프 Metadata
      - 제목, 설명, 미리보기 이미지 등의 정보를 제공하여 소셜 미디어 플랫폼에서 공유할 때 웹페이지가 표시된느 방식을 향상시킴
      - ``` <meta property="og:title" content="Title Here" />
            <meta property="og:description" content="Description Here" />
            <meta property="og:image" content="image_url_here" /> ```
    - 파비콘 Metadata
      - 파비콘(작은 아이콘)을 브라우저의 주소 표시줄이나 탭에 표시되는 웹페이지에 연결
      - ``` <link rel="icon" href="path/to/favicon.ico" /> ```
     
  - 메타데이터 추가
    - 방법
      1. 구성 기반
         - 정적 ```metadata``` 개체 또는 동적 ```generateMetadata``` 함수를 ```layout.js``` 또는 ```page.js``` 파일로 내보냄
      2. 파일 기반
         - Next.js에는 메타데이터 목적으로 특별히 사용되는 다양한 특수 파일이 있다
           - ```favicon.ico, apple-icon.jpg, 및 icon.jpg```: 파비콘 및 아이콘에 활용
           - ```opengraph-image.jpg및 twitter-image.jpg```: 소셜 미디어 이미지를 위해 고용
           - ```robots.txt```: 검색엔진 크롤링에 대한 지침을 제공
           - ```sitemap.xml```: 웹사이트의 구조에 대한 정보를 제공
    - 두 가지 옵션을 모두 사용하면 Next.js가 페이지에 대한 관련 ```<head>``` 요소를 자동으로 생성
    - ```ImageResponse``` 생성자를 사용하여 동적 OG 이미지 만들 수 있다.
    - 중첩된 페이지의 메타데이터는 상위 페이지의 메타데이터보다 우선 적용
  - Next.js 메타데이터 API는 강력하고 유연하여 애플리케이션의 메타데이터를 완벽하게 제어할 수 있다.
  - ```keywords, robots, canonical``` 등을 포함한 여러 필드를 추가 가능
